#!/usr/bin/env python
#-*- coding: UTF8 -*-
import logging
import logging.handlers
import sys
import yaml

import MySQLdb
import zmq
import socket
import os

#日志级别
LOGLEVELS={'DEBUG':logging.DEBUG,
           'INFO':logging.INFO,
           'WARNING':logging.WARNING,
           'ERROR':logging.ERROR,
           'CRITICAL':logging.CRITICAL}

#Zmon的基类，定义了一些公有的方法
class ZBase(object):
    'Base class of zmon'
    logger = None
    def __init__(self,moduleName = 'ZBase'):
        self.moduleName = 'ZBase'
        self.InitConf()
    	self.InitPath()
        self.InitLog()

    #初始化公有配置
    def InitConf(self):
        f = open('conf/zmon.yaml', 'r')
        self.yaml = yaml.load(f)
        f.close()
        self.logLevel = self.yaml['log']['level']
        self.logName = self.yaml['log']['name']
        self.mysqlIp = self.yaml['mysql']['ip']
        self.mysqlPort = int(self.yaml['mysql']['port'])
        self.mysqlUser = self.yaml['mysql']['user']
        self.mysqlPass = self.yaml['mysql']['pass']
        self.listenport = self.yaml['listenport'] 

    #跟进key取对应的配置项
    def GetConf(self, key):
        return self.yaml.get(key)

    #初始化python的lib库目录
    def InitPath(self):
        try:
    	    sys.path.insert(0,'/home/space/zmon/python/lib')
    	    sys.path.insert(0,'/home/space/zmon/redis/python:/home/space/zmon/scripts/rms"')
        except:
            pass
    
    #初始化日志模块
    def InitLog(self):
        #如果基类的logger还没初始化则新建一个
        if ZBase.logger == None:
            ZBase.logger=logging.getLogger()
            filename = 'log/%s' % self.logName
            handler = logging.handlers.TimedRotatingFileHandler(filename, when='H', interval=1, backupCount=24)
            formatter = logging.Formatter('%(levelname)-5s %(asctime)s %(filename)s %(lineno)-4d %(funcName)s %(message)s')
            handler.setFormatter(formatter)
            ZBase.logger.addHandler(handler)
            ZBase.logger.setLevel(LOGLEVELS.get(self.logLevel,logging.INFO))
        #使用基类的logger
        self.logger = ZBase.logger

    #调用数据库的接口
    def ExecSql(self,sql):
        try:
            logging.debug('%s,%s,%s,%s,%s' % (self.mysqlIp, self.mysqlPort, self.mysqlUser, self.mysqlPass,'zmon'))
            conn = MySQLdb.connect(host=self.mysqlIp,port=self.mysqlPort,user=self.mysqlUser,passwd=self.mysqlPass,db='zmon')
            cursor = conn.cursor()
        except Exception,e:
            logging.critical('Connet to mysql faile!,error: %s' % e)
            return None
        try:
            cursor.execute(sql)
            result = cursor.fetchall()
            logging.debug('Execute sql : "%s" success! Return rusult : %s' % (sql, result))
            return result
        except Exception,e:
            logging.exception('Execute Sql Raise Exception')
            return None
        finally:
            cursor.close()
            conn.close()
    #把字符串转换成列表，同时对列表中的元素进行简单处理，如strip等
    def strToList(self, scrString, separator = None):
        resultList = []
        tmplist = scrString.split(separator)
        for i in tmplist:
            if not i == '':
                t = i.strip().replace(' ','')
                resultList.append(t)
        return resultList


    #根据分隔符把列表转换成字符串
    def listToStr(self, scrList, separator = ','):
        resultStr = ''
        for i in scrList:
            if not i == '':
                resultStr += '%s%s' % (i, separator)
        return resultStr.rstrip(separator)

    #给其他模块发送命令的接口
    def SendCmd(self,server_ip,port,cmd):
            ctx = zmq.Context()
            pub = ctx.socket(zmq.PUB)
            pub.connect('tcp://%s:%s' % (server_ip,port))
            pub.setsockopt(zmq.HWM, 1024)
            pub.send_multipart(cmd)
    
    #根据产品线和监控项名取对应redis的ip和port
    def GetRedis(self, product, monitor):
        result = self.ExecSql("select IP,PORT from redis where TYPE = '%s'" % product)
        try:
            ip = result[0][0]
            port = int(result[0][1])
            logging.debug('product: %s,monitor: %s get redis success, result: [ip : %s, port : %s]' % (product, monitor, ip, port))
            return ip,port
        except:
            logging.error('Get Redis from mysql is null, product: %s,monitor: %s' % (product, monitor))
            return None,None

    #根据产品线和监控项名取对应的ZCM_ADDR
    def GetZcm(self, product, monitor):
        result = self.ExecSql("select ZCM_ADDR from redis where PRODUCT = '%s' and NAME = '%s'" % (product, monitor))
        try:
            zcm_addr = result[0][0]
            logging.debug('product: %s,monitor: %s get zcm addr success, result: [%s]' % (product, monitor, zcm_addr))
            return zcm_addr
        except:
            logging.error('Get zcm addr from mysql is null, product: %s,monitor: %s' % (product, monitor))
            return None

    #根据产品线和监控项名取对应的ZCM_Sock
    def GetZcmSock(self, product, monitor):
        p = os.path.abspath('')
        zmonpath = os.path.dirname(p)
        return 'ipc://%s/zcm/socket/monflow/%s/%s.sock' % (zmonpath, product, monitor)

    #根据产品线和监控项名取对应的ZCM_KEY
    def GetZcmKey(self, product, monitor):
        return '/zmon/monflow/%s/%s' % (product, monitor)

    #初始化Zmq，监听指定端口,接收数据
    def initSub(self):
        self.ctx = zmq.Context()
        self.sub = self.ctx.socket(zmq.SUB)
        self.sub.setsockopt(zmq.SUBSCRIBE, '')
        self.sub.bind('tcp://0.0.0.0:%s' % str(self.listenport))
        self.logger.info('begin to listen tcp://0.0.0.0:%s' % self.listenport)

    def destorySub(self):
        if self.sub:
            self.sub.close()
        if self.ctx:
            self.ctx.destroy()

if __name__ == '__main__':
    zb = ZBase()
