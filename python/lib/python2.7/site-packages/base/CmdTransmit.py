#!/usr/bin/env python
#-*- coding:UTF-8 -*-
import zmq
import sys
import socket
import logging
import logging.handlers
import time
import threading
import Queue
from Queue import Empty
import signal


#标志子线程是否需要退出
CMD_TRANSMIT_EXIT_TAG = False
#主进程被终止时的处理方法，保证主进程退出后子线程能够正常退出
def SignalHandler(sig,id):
#    CMD_TRANSMIT_EXIT_TAG = True
    logging.debug(CMD_TRANSMIT_EXIT_TAG)
signal.signal(signal.SIGINT,SignalHandler)
signal.signal(signal.SIGTERM,SignalHandler)

class CmdTransmit(object):
    def __init__(self):
        global CMD_TRANSMIT_EXIT_TAG
        CMD_TRANSMIT_EXIT_TAG = False
        self.queue = Queue.Queue()
        for i in range(3):
            zt = ZmqThread(self.queue)
            zt.start()

    def addTask(self, task):
        self.queue.put(task)
        logging.debug('add cmd %s' % str(task))

    def sendCmd(self, hostIp, port, cmd):
        task = {'hostIp':hostIp, 'port':int(port), 'cmd':cmd}
        self.addTask(task)

    def wait(self):
        logging.debug('wait ZmqThread finish!')
        self.queue.join()

    def stop(self):
        global CMD_TRANSMIT_EXIT_TAG
        logging.debug('send exit signal to ZmqThread')
        CMD_TRANSMIT_EXIT_TAG = True
        

class ZmqThread(threading.Thread):
    def __init__(self, queue):
        threading.Thread.__init__(self)
        self.queue = queue
        self.ctx = zmq.Context()

    def run(self):
        sleepTime = 0.001
        while True:
            if CMD_TRANSMIT_EXIT_TAG == True:
                logging.info('receive exit cmd, so i kill myself!')
                sys.exit()
            try:
                task = self.queue.get_nowait()
                logging.info('get tast %s from queue' % str(task))
                #重试3次
                for i in range(3):
                    #执行任务并跟踪处理结果
                    result = self.execTask(task)
                    #运行成功则直接退出，不需要重试
                    if result == True:
                        break
                    time.sleep(sleepTime)
                self.queue.task_done()
            except Empty:
                logging.debug('the task queue is null, so i wait %s second' % sleepTime)
                time.sleep(sleepTime)
            except Exception,e:
                logging.exception(e)

    def execTask(self, task):
        ip = task['hostIp']
        port = task['port']
        cmd = task['cmd']
        if False == healthCheck(ip, port):
            return False
        try:
            pub = self.ctx.socket(zmq.PUB)
            pub.connect('tcp://%s:%s' % (ip, port))
            pub.setsockopt(zmq.HWM, 1024)
            pub.send_multipart(cmd)
            pub.close()
            logging.debug('send cmd:%s success!' % str(task))
            return True
        except Exception,e:
            logging.exception(e)
            return False
        
#健康检查，检测指定ip的端口是否存活
def healthCheck(hostIp, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(3)
    try:
        s.connect((hostIp, port))
        s.close()
        logging.debug('connect to ip:%s, port:%s success' % (hostIp, port))
        return True
    except Exception, e:
        logging.warning('connect to ip:%s, port:%s faile, error: %s' % (hostIp, port, e))
        s.close()
        return False

if __name__ == '__main__':
    ct = CmdTransmit()
    task = {'hostIp':'10.38.45.17', 'port':7111, 'cmd':['ZMON_RELOAD', 'imgcm', 'space']}
    ct.addTask(task)
    ct.addTask(task)
    ct.addTask(task)
    ct.addTask(task)
    ct.addTask(task)
    ct.addTask(task)
    ct.addTask(task)
    ct.wait()
    ct.stop()
